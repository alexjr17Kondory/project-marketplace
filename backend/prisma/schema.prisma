generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ==================== USUARIOS ====================

model User {
  id           Int     @id @default(autoincrement())
  email        String  @unique
  passwordHash String
  name         String
  phone        String?
  cedula       String?
  avatar       String?

  roleId Int
  role   Role @relation(fields: [roleId], references: [id])

  status UserStatus @default(ACTIVE)

  resetToken    String?
  resetTokenExp DateTime?

  addresses Address[]
  orders    Order[]

  // Relación para ventas POS (como vendedor/cajero)
  salesAsSeller  Order[]       @relation("SellerOrders")
  cashSessions   CashSession[]

  // Carrito de compras
  cart Cart?

  // Reviews y notificaciones
  reviews       Review[]
  helpfulVotes  ReviewHelpfulVote[]
  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Address {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  label      String
  address    String
  city       String
  department String?
  postalCode String?
  country    String  @default("Colombia")
  isDefault  Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("addresses")
}

// ==================== CARRITO DE COMPRAS ====================

model Cart {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  items CartItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("carts")
}

model CartItem {
  id     Int  @id @default(autoincrement())
  cartId Int
  cart   Cart @relation(fields: [cartId], references: [id], onDelete: Cascade)

  // Para productos normales
  productId Int?
  variantId Int?

  // Para productos personalizados (templates)
  isCustomized  Boolean @default(false)
  customization Json?   // Contiene todo el objeto CustomizedProduct

  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cartId])
  @@map("cart_items")
}

model Role {
  id          Int     @id @default(autoincrement())
  name        String
  slug        String  @unique
  description String
  permissions Json
  isSystem    Boolean @default(false)
  isActive    Boolean @default(true)

  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("roles")
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

// ==================== PRODUCTOS ====================

model Product {
  id          Int     @id @default(autoincrement())
  sku         String  @unique
  slug        String  @unique
  name        String
  description String  @db.Text
  barcode     String? @unique // Código de barras para templates (productos usan variant.barcode)

  // Relaciones con categoría y tipo de producto
  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  typeId      Int?
  productType ProductType? @relation(fields: [typeId], references: [id], onDelete: SetNull)

  basePrice  Decimal @db.Decimal(10, 2)
  stock      Int     @default(0)
  featured   Boolean @default(false)
  isActive   Boolean @default(true)
  isTemplate Boolean @default(false) // Si es true, es un modelo/plantilla para personalización

  images Json
  tags   Json

  // Imágenes por tipo de zona (solo para templates)
  // Formato: { "front": "url/base64", "back": "url/base64", ... }
  zoneTypeImages Json?

  // Zonas de diseño (habilitadas y bloqueadas) para personalización (solo para templates)
  // Formato: { "front": [{ type: "allowed|blocked", shape: "rect|circle|polygon", x, y, width, height, ... }], ... }
  designZones Json?

  // @deprecated - usar designZones
  exclusionZones Json?

  // Relaciones many-to-many con colores y tallas
  productColors ProductColor[]
  productSizes  ProductSize[]

  // Relación con variantes (cada combinación color+talla)
  variants ProductVariant[]

  rating       Decimal? @db.Decimal(2, 1)
  reviewsCount Int?     @default(0)

  orderItems OrderItem[]
  reviews    Review[]

  // Relación con zonas de template (si isTemplate = true)
  templateZones TemplateZone[]

  // Relación con insumos (para templates)
  productInputs ProductInput[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("products")
}

model Size {
  id           Int     @id @default(autoincrement())
  name         String
  abbreviation String  @unique
  sortOrder    Int
  isActive     Boolean @default(true)

  productSizes     ProductSize[]
  productTypeSizes ProductTypeSize[]
  variants         ProductVariant[]

  // Relaciones para insumos con variantes
  inputTypeSizes InputTypeSize[]
  inputSizes     InputSize[]
  inputVariants  InputVariant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sizes")
}

model Color {
  id       Int     @id @default(autoincrement())
  name     String
  slug     String  @unique
  hexCode  String
  isActive Boolean @default(true)

  productColors ProductColor[]
  variants      ProductVariant[]

  // Relaciones para insumos con variantes
  inputColors   InputColor[]
  inputVariants InputVariant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("colors")
}

// Tabla intermedia para productos y colores
model ProductColor {
  id        Int     @id @default(autoincrement())
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  colorId   Int
  color     Color   @relation(fields: [colorId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([productId, colorId])
  @@map("product_colors")
}

// Tabla intermedia para productos y tallas
model ProductSize {
  id        Int     @id @default(autoincrement())
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  sizeId    Int
  size      Size    @relation(fields: [sizeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([productId, sizeId])
  @@map("product_sizes")
}

// Tabla intermedia para templates e insumos (relación simple sin variantes)
model ProductInput {
  id        Int     @id @default(autoincrement())
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  inputId   Int
  input     Input   @relation(fields: [inputId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([productId, inputId])
  @@map("product_inputs")
}

// Variante de producto (combinación única de producto + color + talla)
// Ahora soporta productos sin colores o tallas (variante única)
model ProductVariant {
  id        Int     @id @default(autoincrement())
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  colorId Int?
  color   Color? @relation(fields: [colorId], references: [id])

  sizeId Int?
  size   Size? @relation(fields: [sizeId], references: [id])

  // Códigos únicos
  sku     String  @unique // SKU específico (ej: "CAM-001-M-ROJO")
  barcode String? @unique // Código de barras EAN-13/UPC/Code128

  // Stock individual por variante
  stock    Int @default(0)
  minStock Int @default(0) // Stock mínimo para alertas

  // Precio puede variar por variante (opcional)
  priceAdjustment Decimal? @db.Decimal(10, 2)

  // Control
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  orderItems         OrderItem[]
  purchaseOrderItems PurchaseOrderItem[]
  movements          VariantMovement[]
  templateRecipes    TemplateRecipe[] // Recipes for template variants (1:N - multiple ingredients)

  @@index([productId])
  @@index([barcode])
  @@index([sku])
  @@index([productId, colorId, sizeId])
  @@map("product_variants")
}

// Tabla intermedia para tipos de producto y tallas
model ProductTypeSize {
  id            Int         @id @default(autoincrement())
  productTypeId Int
  productType   ProductType @relation(fields: [productTypeId], references: [id], onDelete: Cascade)
  sizeId        Int
  size          Size        @relation(fields: [sizeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([productTypeId, sizeId])
  @@map("product_type_sizes")
}

model Category {
  id          Int     @id @default(autoincrement())
  name        String
  slug        String  @unique
  description String?
  isActive    Boolean @default(true)

  productTypes ProductType[]
  products     Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("categories")
}

model ProductType {
  id          Int     @id @default(autoincrement())
  name        String
  slug        String  @unique
  description String?
  isActive    Boolean @default(true)

  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  products         Product[]
  productTypeSizes ProductTypeSize[]
  labelTemplates   LabelTemplateProductType[] // Many-to-many con plantillas de etiquetas

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("product_types")
}

// ==================== PEDIDOS ====================

model Order {
  id          Int    @id @default(autoincrement())
  orderNumber String @unique

  userId Int?
  user   User? @relation(fields: [userId], references: [id])

  // Cliente POS (separado de usuarios de tienda online)
  posCustomerId Int?
  posCustomer   POSCustomer? @relation(fields: [posCustomerId], references: [id])

  // Datos del cliente para ventas POS sin usuario registrado
  customerName  String?
  customerEmail String?
  customerPhone String?

  items OrderItem[]

  subtotal     Decimal @db.Decimal(10, 2)
  shippingCost Decimal @default(0) @db.Decimal(10, 2)
  discount     Decimal @default(0) @db.Decimal(10, 2)
  tax          Decimal @default(0) @db.Decimal(10, 2)
  total        Decimal @db.Decimal(10, 2)

  status        OrderStatus @default(PENDING)
  paymentMethod String // Método preferido (puede cambiar con cada intento)
  paymentRef    String? // Referencia del último pago exitoso

  // Campos para pagos POS:
  cashAmount    Decimal? @db.Decimal(10, 2) // Monto pagado en efectivo
  cardAmount    Decimal? @db.Decimal(10, 2) // Monto pagado con tarjeta
  cardReference String? // Referencia/autorización del datafono
  cardType      String? // Tipo de tarjeta (Visa, Mastercard, etc.)
  cardLastFour  String? // Últimos 4 dígitos de la tarjeta
  paymentEvidence String? @db.LongText // URL/base64 de imagen de evidencia de pago (transferencias)

  // NUEVOS CAMPOS POS:
  saleChannel    SaleChannel @default(ONLINE)
  sellerId       Int?
  seller         User?         @relation("SellerOrders", fields: [sellerId], references: [id])
  cashRegisterId Int?
  cashRegister   CashRegister? @relation(fields: [cashRegisterId], references: [id])

  shipping       Json? // Opcional (NULL para ventas POS)
  trackingNumber String?
  trackingUrl    String?
  notes          String? @db.Text

  statusHistory Json

  // Relación con pagos (un pedido puede tener múltiples intentos de pago)
  payments Payment[]

  paidAt      DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("orders")
}

model OrderItem {
  id      Int   @id @default(autoincrement())
  orderId Int
  order   Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId    Int
  product      Product @relation(fields: [productId], references: [id])
  productName  String
  productImage String @db.LongText

  // NUEVO: Relación con variante (para control de stock por variante)
  variantId Int?
  variant   ProductVariant? @relation(fields: [variantId], references: [id])

  size      String
  color     String
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)

  customization Json?

  createdAt DateTime @default(now())

  @@map("order_items")
}

enum OrderStatus {
  PENDING
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

enum SaleChannel {
  ONLINE
  POS
}

// ==================== PAGOS ====================

model Payment {
  id          Int    @id @default(autoincrement())
  orderId     Int
  order       Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Información de la transacción
  transactionId String? @unique // ID de la pasarela de pago (Wompi, MercadoPago, etc.)
  paymentMethod String           // "wompi", "mercadopago", "transferencia", "efectivo", etc.

  // Montos
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("COP")

  // Estado del pago
  status PaymentStatus @default(PENDING)

  // Comprobantes
  receiptUrl  String? @db.VarChar(500) // URL del comprobante de pago
  receiptData String? @db.LongText     // Comprobante en base64 (si se sube imagen)

  // Información adicional del pago
  payerName     String? // Nombre del pagador
  payerEmail    String? // Email del pagador
  payerPhone    String? // Teléfono del pagador
  payerDocument String? // Documento del pagador

  // Razón de fallo/cancelación
  failureReason String? @db.Text
  failureCode   String? // Código de error de la pasarela

  // Verificación manual
  verifiedBy Int? // ID del usuario admin que verificó manualmente
  verifiedAt DateTime? // Cuando se verificó el pago
  notes      String? @db.Text // Notas del admin sobre el pago

  // Reembolsos
  refundedAmount Decimal @default(0) @db.Decimal(10, 2)
  refundedAt     DateTime?
  refundReason   String? @db.Text

  // Timestamps importantes
  initiatedAt DateTime @default(now()) // Cuando se inició el intento de pago
  paidAt      DateTime? // Cuando se confirmó el pago
  failedAt    DateTime? // Cuando falló el pago
  cancelledAt DateTime? // Cuando se canceló
  expiredAt   DateTime? // Cuando expiró el intento

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([transactionId])
  @@index([status])
  @@index([paymentMethod])
  @@index([initiatedAt])
  @@map("payments")
}

enum PaymentStatus {
  PENDING       // Pago iniciado, esperando confirmación
  PROCESSING    // En proceso de verificación
  APPROVED      // Pago aprobado y confirmado
  DECLINED      // Pago rechazado por el banco/pasarela
  FAILED        // Pago fallido (error técnico)
  CANCELLED     // Pago cancelado por el usuario
  EXPIRED       // Intento de pago expirado
  REFUNDED      // Pago reembolsado completamente
  PARTIAL_REFUND // Reembolso parcial
}

// ==================== PUNTO DE VENTA (POS) ====================

// Cliente de POS (separado de User - NO puede hacer login)
model POSCustomer {
  id     Int    @id @default(autoincrement())
  cedula String @unique // Cédula/NIT - identificador principal

  name   String
  email  String?
  phone  String?

  // Estadísticas de compras
  totalPurchases Int     @default(0) // Número total de compras
  totalSpent     Decimal @default(0) @db.Decimal(10, 2) // Monto total gastado

  // Órdenes asociadas
  orders Order[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cedula])
  @@index([name])
  @@map("pos_customers")
}

model CashRegister {
  id       Int     @id @default(autoincrement())
  name     String
  location String
  code     String  @unique
  isActive Boolean @default(true)

  orders       Order[]
  cashSessions CashSession[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("cash_registers")
}

model CashSession {
  id             Int          @id @default(autoincrement())
  cashRegisterId Int
  cashRegister   CashRegister @relation(fields: [cashRegisterId], references: [id])

  sellerId Int
  seller   User @relation(fields: [sellerId], references: [id])

  openedAt DateTime  @default(now())
  closedAt DateTime?

  initialCash  Decimal  @db.Decimal(10, 2)
  finalCash    Decimal? @db.Decimal(10, 2)
  expectedCash Decimal? @db.Decimal(10, 2)
  difference   Decimal? @db.Decimal(10, 2)

  salesCount Int     @default(0)
  totalSales Decimal @default(0) @db.Decimal(10, 2)

  notes  String?       @db.Text
  status SessionStatus @default(OPEN)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cashRegisterId])
  @@index([sellerId])
  @@index([status])
  @@map("cash_sessions")
}

enum SessionStatus {
  OPEN
  CLOSED
}

// ==================== CONFIGURACION ====================

model Setting {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt

  @@map("settings")
}

// ==================== TEMPLATES Y ZONAS ====================

// Tipo de Zona (catálogo: Frente, Espalda, Mangas, etc.)
model ZoneType {
  id          Int     @id @default(autoincrement())
  name        String // "Frente", "Espalda", "Manga"
  slug        String  @unique // "front", "back", "sleeve"
  description String? @db.Text
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)

  zones TemplateZone[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("zone_types")
}

// Zona específica de un template
model TemplateZone {
  id         Int     @id @default(autoincrement())
  templateId Int // FK a Product (donde isTemplate = true)
  template   Product @relation(fields: [templateId], references: [id], onDelete: Cascade)

  zoneTypeId Int // FK a ZoneType
  zoneType   ZoneType @relation(fields: [zoneTypeId], references: [id])

  // Identificador de zona según PrintZone type
  zoneId String // 'front-regular', 'back-large', 'sleeve-small', etc.

  // Información de la zona
  name        String // "Frente Regular (18x25cm)"
  description String? @db.Text

  // Forma de la zona: rect, circle, polygon
  shape String @default("rect") // 'rect' | 'circle' | 'polygon'

  // Dimensiones máximas de la zona (en porcentaje 0-100)
  maxWidth  Int // Ancho en %
  maxHeight Int // Alto en %

  // Posición en el canvas (en porcentaje 0-100)
  positionX Int // Coordenada X en %
  positionY Int // Coordenada Y en %

  // Para círculos (radio en %)
  radius Int? // Solo para shape='circle'

  // Para polígonos (puntos relativos 0-100 dentro del bounding box)
  // Formato JSON: [{"x": 50, "y": 0}, {"x": 100, "y": 100}, {"x": 0, "y": 100}]
  points Json?

  // Control de usuario
  isEditable Boolean @default(true) // Si el usuario puede modificar esta zona
  isRequired Boolean @default(false) // Si es obligatorio que el usuario agregue diseño

  // NUEVO: Si es zona bloqueada (donde NO se puede poner diseño)
  isBlocked Boolean @default(false) // true = zona bloqueada (roja), false = zona de diseño (normal)

  // Precio de la zona (para ventas POS de productos personalizados)
  price Decimal @default(0) @db.Decimal(10, 2) // Precio adicional por personalizar esta zona

  sortOrder Int     @default(0)
  isActive  Boolean @default(true)

  // Una zona puede tener UN insumo predefinido (solo para zonas no bloqueadas)
  zoneInput ZoneInput?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
  @@index([zoneTypeId])
  @@map("template_zones")
}

// Insumo/Diseño predefinido de una zona
model ZoneInput {
  id             Int          @id @default(autoincrement())
  templateZoneId Int          @unique // FK a TemplateZone (relación 1:1)
  templateZone   TemplateZone @relation(fields: [templateZoneId], references: [id], onDelete: Cascade)

  // Relación con insumo del inventario
  inputId Int? // FK a Input (insumo del inventario)
  input   Input? @relation(fields: [inputId], references: [id], onDelete: SetNull)

  // Imagen del insumo
  imageUrl          String // URL pública de la imagen
  imageData         String? @db.LongText // Base64 comprimida (para preview rápido)
  originalImageData String? @db.LongText // Base64 original (para producción)
  fileName          String?
  fileSize          Int? // Tamaño en bytes

  // Propiedades del diseño
  positionX Int   @default(0)
  positionY Int   @default(0)
  width     Int   @default(100)
  height    Int   @default(100)
  rotation  Float @default(0) // En grados
  opacity   Float @default(1) // 0 a 1

  // Control
  isLocked Boolean @default(false) // Si está bloqueado, el usuario NO puede modificar/eliminar

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([inputId])
  @@map("zone_inputs")
}

// ==================== RECETAS DE TEMPLATES ====================

// Receta de template (asocia variante de template con múltiples insumos)
model TemplateRecipe {
  id        Int @id @default(autoincrement())

  // Variante de template (producto donde isTemplate = true)
  variantId Int // Relación 1:N - cada variante puede tener MÚLTIPLES insumos
  variant   ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  // Variante de insumo
  inputVariantId Int
  inputVariant   InputVariant @relation(fields: [inputVariantId], references: [id])

  // Cantidad de insumo necesaria por unidad de template
  quantity Decimal @default(1) @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([variantId, inputVariantId]) // Prevenir duplicados de mismo insumo en misma variante
  @@index([variantId])
  @@index([inputVariantId])
  @@map("template_recipes")
}

// ==================== INVENTARIO DE INSUMOS ====================

// Tipo de Insumo (DTF, Vinilo, Sublimación, etc.)
model InputType {
  id          Int     @id @default(autoincrement())
  name        String // "DTF", "Vinilo Textil", "Sublimación", "Camisetas Base"
  slug        String  @unique // "dtf", "vinilo-textil", "sublimacion", "camisetas-base"
  description String? @db.Text
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)

  // Configuración de variantes
  hasVariants Boolean @default(false) // Si true, los insumos de este tipo tienen tallas/colores

  inputs         Input[]
  inputTypeSizes InputTypeSize[] // Tallas disponibles para este tipo de insumo

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("input_types")
}

// Tabla intermedia para tipos de insumo y tallas
model InputTypeSize {
  id          Int       @id @default(autoincrement())
  inputTypeId Int
  inputType   InputType @relation(fields: [inputTypeId], references: [id], onDelete: Cascade)
  sizeId      Int
  size        Size      @relation(fields: [sizeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([inputTypeId, sizeId])
  @@map("input_type_sizes")
}

// Insumo (material de inventario)
model Input {
  id          Int     @id @default(autoincrement())
  code        String  @unique // Código único del insumo
  name        String // Nombre descriptivo
  description String? @db.Text

  inputTypeId Int // FK a InputType
  inputType   InputType @relation(fields: [inputTypeId], references: [id])

  // Información del insumo
  unitOfMeasure String // "cm²", "unidad", "metro", etc.
  unitCost      Decimal @db.Decimal(10, 2) // Costo por unidad (para insumos sin variantes)

  // Stock (para insumos SIN variantes - cuando InputType.hasVariants = false)
  currentStock Decimal @default(0) @db.Decimal(10, 2) // Stock actual
  minStock     Decimal @default(0) @db.Decimal(10, 2) // Stock mínimo (alerta)
  maxStock     Decimal @default(0) @db.Decimal(10, 2) // Stock máximo

  // Información adicional
  supplier     String? // Proveedor
  supplierCode String? // Código del proveedor
  notes        String? @db.Text

  isActive Boolean @default(true)

  // Relaciones
  batches            InputBatch[] // Lotes de este insumo
  movements          InputBatchMovement[] // Movimientos de inventario
  zoneInputs         ZoneInput[] // Zonas que usan este insumo
  purchaseOrderItems PurchaseOrderItem[] // Items de órdenes de compra

  // Relaciones para variantes (cuando InputType.hasVariants = true)
  inputColors InputColor[] // Colores disponibles para este insumo
  inputSizes  InputSize[] // Tallas disponibles para este insumo
  variants    InputVariant[] // Variantes (combinaciones color+talla)

  // Relación con templates
  productInputs ProductInput[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([inputTypeId])
  @@map("inputs")
}

// Tabla intermedia para insumos y colores
model InputColor {
  id      Int   @id @default(autoincrement())
  inputId Int
  input   Input @relation(fields: [inputId], references: [id], onDelete: Cascade)
  colorId Int
  color   Color @relation(fields: [colorId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([inputId, colorId])
  @@map("input_colors")
}

// Tabla intermedia para insumos y tallas
model InputSize {
  id      Int   @id @default(autoincrement())
  inputId Int
  input   Input @relation(fields: [inputId], references: [id], onDelete: Cascade)
  sizeId  Int
  size    Size  @relation(fields: [sizeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([inputId, sizeId])
  @@map("input_sizes")
}

// Variante de Insumo (combinación específica de color+talla)
model InputVariant {
  id      Int   @id @default(autoincrement())
  inputId Int
  input   Input @relation(fields: [inputId], references: [id], onDelete: Cascade)

  // Color y talla de esta variante
  colorId Int?
  color   Color? @relation(fields: [colorId], references: [id], onDelete: SetNull)
  sizeId  Int?
  size    Size?  @relation(fields: [sizeId], references: [id], onDelete: SetNull)

  // SKU único para esta variante
  sku String @unique

  // Costos
  unitCost Decimal @db.Decimal(10, 2) // Costo por unidad de esta variante

  // Stock de esta variante específica
  currentStock Decimal @default(0) @db.Decimal(10, 2)
  minStock     Decimal @default(0) @db.Decimal(10, 2)
  maxStock     Decimal @default(0) @db.Decimal(10, 2)

  isActive Boolean @default(true)

  // Relaciones
  purchaseOrderItems PurchaseOrderItem[] // Items de órdenes de compra
  movements          InputVariantMovement[] // Movimientos de inventario
  templateRecipes    TemplateRecipe[] // Templates que usan este insumo como base

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([inputId, colorId, sizeId])
  @@index([inputId])
  @@index([colorId])
  @@index([sizeId])
  @@map("input_variants")
}

// Movimiento de Variante de Insumo
model InputVariantMovement {
  id             Int          @id @default(autoincrement())
  inputVariantId Int
  inputVariant   InputVariant @relation(fields: [inputVariantId], references: [id], onDelete: Cascade)

  // Tipo de movimiento
  movementType MovementType

  // Cantidad (positiva para entradas, negativa para salidas)
  quantity      Decimal @db.Decimal(10, 2) // Cantidad del movimiento
  previousStock Decimal @db.Decimal(10, 2) // Stock antes del movimiento
  newStock      Decimal @db.Decimal(10, 2) // Stock después del movimiento

  // Referencias
  referenceType String? // "purchase_order", "production", "adjustment", "transfer"
  referenceId   Int? // ID de la referencia

  // Detalles
  reason String? @db.Text // Razón del movimiento
  notes  String? @db.Text

  // Usuario que realizó el movimiento
  userId Int?

  // Costo unitario (para entradas de compra)
  unitCost Decimal? @db.Decimal(10, 2)

  createdAt DateTime @default(now())

  @@index([inputVariantId])
  @@index([movementType])
  @@index([createdAt])
  @@map("input_variant_movements")
}

// Lote de Insumo (entrada de inventario)
model InputBatch {
  id      Int   @id @default(autoincrement())
  inputId Int // FK a Input
  input   Input @relation(fields: [inputId], references: [id], onDelete: Cascade)

  batchNumber String // Número de lote
  supplier    String? // Proveedor de este lote
  invoiceRef  String? // Referencia de factura

  // Cantidades
  initialQuantity  Decimal @db.Decimal(10, 2) // Cantidad inicial del lote
  currentQuantity  Decimal @db.Decimal(10, 2) // Cantidad actual disponible
  reservedQuantity Decimal @default(0) @db.Decimal(10, 2) // Cantidad reservada

  // Costos
  unitCost  Decimal @db.Decimal(10, 2) // Costo unitario de este lote
  totalCost Decimal @db.Decimal(10, 2) // Costo total del lote

  // Fechas
  purchaseDate DateTime? // Fecha de compra
  expiryDate   DateTime? // Fecha de vencimiento (si aplica)

  notes String? @db.Text

  isActive Boolean @default(true)

  movements InputBatchMovement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([inputId, batchNumber])
  @@index([inputId])
  @@map("input_batches")
}

// Movimiento de Lote de Insumo
model InputBatchMovement {
  id           Int        @id @default(autoincrement())
  inputId      Int // FK a Input
  input        Input      @relation(fields: [inputId], references: [id], onDelete: Cascade)
  inputBatchId Int // FK a InputBatch
  inputBatch   InputBatch @relation(fields: [inputBatchId], references: [id], onDelete: Cascade)

  movementType MovementType // ENTRADA, SALIDA, AJUSTE, RESERVA, LIBERACION
  quantity     Decimal      @db.Decimal(10, 2) // Cantidad del movimiento (positiva o negativa)

  // Referencias
  referenceType String? // "order", "production", "adjustment", "return"
  referenceId   Int? // ID de la referencia (ej: orderId, productionId)

  reason String? @db.Text // Razón del movimiento
  notes  String? @db.Text

  userId Int? // Usuario que realizó el movimiento

  createdAt DateTime @default(now())

  @@index([inputId])
  @@index([inputBatchId])
  @@index([movementType])
  @@index([createdAt])
  @@map("input_batch_movements")
}

enum MovementType {
  ENTRADA // Entrada de inventario (compra)
  SALIDA // Salida de inventario (uso en producción)
  AJUSTE // Ajuste de inventario (corrección)
  RESERVA // Reserva de inventario (para orden)
  LIBERACION // Liberación de reserva
  DEVOLUCION // Devolución
  MERMA // Pérdida/merma
}

// ==================== CATÁLOGO DE IMÁGENES DE DISEÑO ====================

// Imágenes prediseñadas para el personalizador
model DesignImage {
  id          Int     @id @default(autoincrement())
  name        String // Nombre descriptivo
  description String? @db.Text

  // URLs de las imágenes
  thumbnailUrl String @db.LongText // Base64 o URL de imagen pequeña/comprimida (para preview)
  fullUrl      String @db.VarChar(500) // URL de imagen original/alta calidad (para pedido)

  // Metadatos
  category String? // Categoría: "iconos", "logos", "textos", "decorativos", etc.
  tags     Json? // Array de etiquetas para búsqueda: ["corazón", "amor", "rojo"]

  sortOrder Int     @default(0)
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([isActive])
  @@map("design_images")
}

// ==================== SISTEMA DE ETIQUETAS PERSONALIZABLES ====================

// Plantilla de etiqueta (con imagen de fondo opcional y zonas posicionables)
model LabelTemplate {
  id   Int    @id @default(autoincrement())
  name String

  // Imagen de fondo (opcional) - si no hay imagen, fondo blanco
  backgroundImage String? @db.LongText // Base64 de la imagen de fondo

  // Dimensiones fijas de la etiqueta (en puntos, 72 DPI)
  // 6 cm × 9 cm = 170.08 × 255.12 puntos
  width  Float @default(170.08) // 6 cm
  height Float @default(255.12) // 9 cm

  // Configuración de página e impresión
  pageType     String @default("A4") // A3, A4, LETTER, CUSTOM
  pageMargin   Float  @default(30) // Margen de la página en puntos (0.7-1 cm)
  labelSpacing Float  @default(10) // Separación entre etiquetas en puntos (0.3-0.4 cm)

  // Configuración
  isDefault Boolean @default(false) // Plantilla por defecto global
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  zones        LabelZone[]
  productTypes LabelTemplateProductType[] // Many-to-many con tipos de producto

  @@index([isDefault])
  @@map("label_templates")
}

// Tabla intermedia: Plantilla de etiqueta ↔ Tipo de producto (Many-to-Many)
model LabelTemplateProductType {
  id              Int           @id @default(autoincrement())
  labelTemplateId Int
  labelTemplate   LabelTemplate @relation(fields: [labelTemplateId], references: [id], onDelete: Cascade)
  productTypeId   Int
  productType     ProductType   @relation(fields: [productTypeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([labelTemplateId, productTypeId])
  @@index([labelTemplateId])
  @@index([productTypeId])
  @@map("label_template_product_types")
}

// Zona/elemento de información en la etiqueta
model LabelZone {
  id              Int           @id @default(autoincrement())
  labelTemplateId Int
  labelTemplate   LabelTemplate @relation(fields: [labelTemplateId], references: [id], onDelete: Cascade)

  // Tipo de zona (qué información muestra)
  zoneType LabelZoneType

  // Posición y dimensiones (en puntos, coordenadas desde esquina superior izquierda)
  x      Float
  y      Float
  width  Float
  height Float

  // Estilo de texto
  fontSize   Int    @default(10)
  fontWeight String @default("normal") // normal, bold
  textAlign  String @default("center") // left, center, right
  fontColor  String @default("#000000") // Color hexadecimal

  // Mostrar label/prefijo (ej: "Talla:", "Color:", "SKU:")
  showLabel Boolean @default(true)

  // Rotación (en grados, 0-360)
  rotation Int @default(0)

  // Orden de renderizado (z-index)
  zIndex Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([labelTemplateId])
  @@index([zoneType])
  @@map("label_zones")
}

// Tipos de zona de etiqueta
enum LabelZoneType {
  PRODUCT_NAME // Nombre del producto
  SIZE         // Talla
  COLOR        // Color
  BARCODE      // Código de barras (imagen)
  BARCODE_TEXT // Número del código de barras
  SKU          // SKU
  PRICE        // Precio
  CUSTOM_TEXT  // Texto personalizado
}

// ==================== PROVEEDORES Y COMPRAS ====================

// Proveedor
model Supplier {
  id   Int    @id @default(autoincrement())
  code String @unique // Código único del proveedor (ej: PROV-001)
  name String // Razón social

  // Identificación fiscal
  taxId     String? // NIT/RUT/RUC
  taxIdType String? // "NIT", "RUT", "RUC", "DNI", etc.

  // Contacto
  contactName  String? // Nombre del contacto principal
  email        String?
  phone        String?
  altPhone     String? // Teléfono alternativo
  website      String?

  // Dirección
  address    String?
  city       String?
  department String? // Estado/Provincia/Departamento
  postalCode String?
  country    String @default("Colombia")

  // Información comercial
  paymentTerms    String? // "Contado", "30 días", "60 días"
  paymentMethod   String? // Método de pago preferido
  bankName        String?
  bankAccountType String? // "Ahorro", "Corriente"
  bankAccount     String?
  notes           String? @db.Text

  // Control
  isActive Boolean @default(true)

  // Relaciones
  purchaseOrders PurchaseOrder[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([taxId])
  @@map("suppliers")
}

// Orden de Compra
model PurchaseOrder {
  id          Int    @id @default(autoincrement())
  orderNumber String @unique // Número de OC (ej: OC-2025-0001)

  supplierId Int
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  // Estado
  status PurchaseOrderStatus @default(DRAFT)

  // Montos
  subtotal Decimal @db.Decimal(10, 2)
  tax      Decimal @default(0) @db.Decimal(10, 2)
  discount Decimal @default(0) @db.Decimal(10, 2)
  total    Decimal @db.Decimal(10, 2)

  // Fechas
  orderDate    DateTime  @default(now()) // Fecha de la OC
  expectedDate DateTime? // Fecha esperada de entrega
  receivedDate DateTime? // Fecha de recepción completa

  // Referencias
  supplierInvoice String? // Número de factura del proveedor
  notes           String? @db.Text

  // Usuario que creó la OC
  createdById Int?

  // Items
  items PurchaseOrderItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([supplierId])
  @@index([status])
  @@index([orderDate])
  @@map("purchase_orders")
}

enum PurchaseOrderStatus {
  DRAFT     // Borrador
  SENT      // Enviada al proveedor
  CONFIRMED // Confirmada por proveedor
  PARTIAL   // Recepción parcial
  RECEIVED  // Recibida completamente
  CANCELLED // Cancelada
}

// Item de Orden de Compra
model PurchaseOrderItem {
  id              Int           @id @default(autoincrement())
  purchaseOrderId Int
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  // Puede ser una variante de producto O un insumo O una variante de insumo
  variantId Int?
  variant   ProductVariant? @relation(fields: [variantId], references: [id])

  // Para insumos SIN variantes (InputType.hasVariants = false)
  inputId Int?
  input   Input? @relation(fields: [inputId], references: [id])

  // Para insumos CON variantes (InputType.hasVariants = true)
  inputVariantId Int?
  inputVariant   InputVariant? @relation(fields: [inputVariantId], references: [id])

  // Descripción (para items no relacionados o referencia)
  description String?

  // Cantidades
  quantity         Decimal @db.Decimal(10, 2) // Cantidad pedida
  quantityReceived Decimal @default(0) @db.Decimal(10, 2) // Cantidad recibida

  // Precios
  unitCost Decimal @db.Decimal(10, 2) // Costo unitario
  subtotal Decimal @db.Decimal(10, 2) // quantity * unitCost

  notes String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([purchaseOrderId])
  @@index([variantId])
  @@index([inputId])
  @@index([inputVariantId])
  @@map("purchase_order_items")
}

// Movimiento de Inventario de Variantes
model VariantMovement {
  id        Int            @id @default(autoincrement())
  variantId Int
  variant   ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  // Tipo de movimiento
  movementType VariantMovementType

  // Cantidad (positiva para entradas, negativa para salidas)
  quantity      Int // Cantidad del movimiento
  previousStock Int // Stock antes del movimiento
  newStock      Int // Stock después del movimiento

  // Referencias
  referenceType String? // "purchase_order", "sale", "adjustment", "transfer", "return"
  referenceId   Int? // ID de la referencia

  // Detalles
  reason String? @db.Text // Razón del movimiento
  notes  String? @db.Text

  // Usuario que realizó el movimiento
  userId Int?

  // Costo unitario (para entradas de compra)
  unitCost Decimal? @db.Decimal(10, 2)

  createdAt DateTime @default(now())

  @@index([variantId])
  @@index([movementType])
  @@index([referenceType, referenceId])
  @@index([createdAt])
  @@map("variant_movements")
}

enum VariantMovementType {
  PURCHASE    // Entrada por compra
  SALE        // Salida por venta
  ADJUSTMENT  // Ajuste de inventario
  TRANSFER_IN // Entrada por transferencia
  TRANSFER_OUT // Salida por transferencia
  RETURN      // Devolución de cliente
  DAMAGE      // Daño/merma
  INITIAL     // Stock inicial
}

// ==================== CONTEO DE INVENTARIO FÍSICO ====================

// Sesión de conteo de inventario
model InventoryCount {
  id          Int    @id @default(autoincrement())
  countNumber String @unique // Número de conteo (ej: INV-2025-0001)

  // Tipo de conteo
  countType InventoryCountType @default(FULL) // Completo o parcial

  // Estado
  status InventoryCountStatus @default(DRAFT)

  // Fecha del conteo
  countDate DateTime @default(now())

  // Usuario que realiza el conteo
  countedById   Int?
  countedByName String? // Nombre del usuario (para referencia)

  // Usuario que aprueba el conteo
  approvedById   Int?
  approvedByName String?
  approvedAt     DateTime?

  // Notas
  notes String? @db.Text

  // Items del conteo
  items InventoryCountItem[]

  // Estadísticas (calculadas al cerrar)
  totalItems       Int @default(0) // Total de items contados
  itemsWithDiff    Int @default(0) // Items con diferencia
  totalDiffValue   Decimal @default(0) @db.Decimal(10, 2) // Valor total de diferencias

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([countDate])
  @@map("inventory_counts")
}

// Item de conteo de inventario
model InventoryCountItem {
  id               Int            @id @default(autoincrement())
  inventoryCountId Int
  inventoryCount   InventoryCount @relation(fields: [inventoryCountId], references: [id], onDelete: Cascade)

  // Referencia al insumo
  inputId Int
  // No ponemos relación directa para evitar problemas si se elimina el insumo

  // Datos del insumo al momento del conteo (snapshot)
  inputCode String
  inputName String
  unitOfMeasure String
  unitCost Decimal @db.Decimal(10, 2)

  // Cantidades
  systemQuantity Decimal @db.Decimal(10, 2) // Cantidad según sistema
  countedQuantity Decimal? @db.Decimal(10, 2) // Cantidad contada físicamente
  difference Decimal? @db.Decimal(10, 2) // Diferencia (countedQuantity - systemQuantity)
  differenceValue Decimal? @db.Decimal(10, 2) // Valor de la diferencia (difference * unitCost)

  // Estado del item
  isCounted Boolean @default(false) // Si ya se contó

  // Notas específicas del item
  notes String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([inventoryCountId, inputId])
  @@index([inventoryCountId])
  @@index([inputId])
  @@map("inventory_count_items")
}

enum InventoryCountType {
  FULL    // Conteo completo (todos los insumos)
  PARTIAL // Conteo parcial (insumos seleccionados)
}

enum InventoryCountStatus {
  DRAFT      // Borrador - en preparación
  IN_PROGRESS // En progreso - contando
  PENDING_APPROVAL // Pendiente de aprobación
  APPROVED   // Aprobado - ajustes aplicados
  CANCELLED  // Cancelado
}

// ==================== CONVERSIÓN DE INVENTARIO ====================

// Conversión de insumos a productos
model InventoryConversion {
  id               Int    @id @default(autoincrement())
  conversionNumber String @unique // Número de conversión (ej: CONV-2025-0001)

  // Tipo de conversión
  conversionType ConversionType @default(MANUAL) // MANUAL o TEMPLATE

  // Referencia a plantilla (solo para conversiones de tipo TEMPLATE)
  templateId Int? // ID del producto plantilla
  templateVariantId Int? // ID de la variante de plantilla (para obtener color/talla)

  // Estado
  status ConversionStatus @default(DRAFT)

  // Fecha de conversión
  conversionDate DateTime @default(now())

  // Usuario que realiza la conversión
  createdById   Int?
  createdByName String?

  // Usuario que aprueba (si requiere aprobación)
  approvedById   Int?
  approvedByName String?
  approvedAt     DateTime?

  // Descripción/motivo
  description String? @db.Text
  notes       String? @db.Text

  // Items de entrada (insumos consumidos)
  inputItems ConversionInputItem[]

  // Items de salida (productos/variantes generados)
  outputItems ConversionOutputItem[]

  // Totales calculados
  totalInputCost  Decimal @default(0) @db.Decimal(10, 2) // Costo total de insumos consumidos
  totalOutputCost Decimal @default(0) @db.Decimal(10, 2) // Valor total de productos generados

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([conversionDate])
  @@index([createdById])
  @@index([conversionType])
  @@index([templateId])
  @@map("inventory_conversions")
}

// Insumo consumido en la conversión (entrada)
model ConversionInputItem {
  id           Int                 @id @default(autoincrement())
  conversionId Int
  conversion   InventoryConversion @relation(fields: [conversionId], references: [id], onDelete: Cascade)

  // Referencia a la variante del insumo
  inputVariantId Int

  // Datos del insumo/variante al momento de la conversión (snapshot)
  inputCode     String
  inputName     String
  variantSku    String
  colorName     String?
  sizeName      String?
  unitOfMeasure String
  unitCost      Decimal @db.Decimal(10, 2)

  // Cantidad consumida
  quantity Decimal @db.Decimal(10, 2)

  // Costo total de este item
  totalCost Decimal @db.Decimal(10, 2) // quantity * unitCost

  notes String? @db.Text

  createdAt DateTime @default(now())

  @@index([conversionId])
  @@index([inputVariantId])
  @@map("conversion_input_items")
}

// Producto/variante generado en la conversión (salida)
model ConversionOutputItem {
  id           Int                 @id @default(autoincrement())
  conversionId Int
  conversion   InventoryConversion @relation(fields: [conversionId], references: [id], onDelete: Cascade)

  // Referencia a la variante de producto
  variantId Int

  // Datos del producto/variante al momento de la conversión (snapshot)
  productName String
  variantSku  String
  colorName   String?
  sizeName    String?
  unitPrice   Decimal @db.Decimal(10, 2) // Precio base del producto

  // Cantidad generada
  quantity Int

  // Valor total de este item
  totalValue Decimal @db.Decimal(10, 2) // quantity * unitPrice

  notes String? @db.Text

  createdAt DateTime @default(now())

  @@index([conversionId])
  @@index([variantId])
  @@map("conversion_output_items")
}

enum ConversionStatus {
  DRAFT     // Borrador - en preparación
  PENDING   // Pendiente de aprobación
  APPROVED  // Aprobada - inventario actualizado
  CANCELLED // Cancelada
}

enum ConversionType {
  MANUAL   // Conversión manual: insumos → productos
  TEMPLATE // Conversión desde plantilla: plantilla + insumo → producto terminado
}

// ==================== REVIEWS Y CALIFICACIONES ====================

// Review de producto (solo usuarios que compraron)
model Review {
  id        Int @id @default(autoincrement())

  // Relaciones
  userId    Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Contenido
  rating  Int          // 1-5 estrellas
  title   String?      @db.VarChar(200)
  comment String       @db.Text

  // Siempre es compra verificada (solo pueden dejar review los que compraron)
  verifiedPurchase Boolean @default(true)

  // Contador de votos útiles
  helpfulCount Int @default(0)

  // Estado de moderación
  status ReviewStatus @default(APPROVED) // Por defecto se publican automáticamente

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Votos de utilidad
  helpfulVotes ReviewHelpfulVote[]

  @@unique([userId, productId]) // Un usuario = una review por producto
  @@index([productId])
  @@index([userId])
  @@index([status])
  @@map("reviews")
}

// Voto de utilidad en review
model ReviewHelpfulVote {
  id       Int     @id @default(autoincrement())
  reviewId Int
  review   Review  @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  userId   Int
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  isHelpful Boolean // true = útil, false = no útil

  createdAt DateTime @default(now())

  @@unique([reviewId, userId]) // Un voto por usuario por review
  @@index([reviewId])
  @@map("review_helpful_votes")
}

enum ReviewStatus {
  PENDING   // Esperando moderación
  APPROVED  // Aprobado y visible
  REJECTED  // Rechazado
}

// ==================== NOTIFICACIONES ====================

// Notificación para usuario
model Notification {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Tipo de notificación
  type NotificationType

  // Contenido
  title   String
  message String @db.Text

  // Referencia opcional (ej: productId, orderId)
  referenceType String? // "product", "order", "review"
  referenceId   Int?

  // Estado
  isRead Boolean @default(false)

  // Timestamps
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([userId, isRead])
  @@index([type])
  @@map("notifications")
}

enum NotificationType {
  REVIEW_AVAILABLE  // Puede dejar review de un producto comprado
  ORDER_STATUS      // Cambio de estado de pedido
  PROMO             // Promoción
  SYSTEM            // Notificación del sistema
}
