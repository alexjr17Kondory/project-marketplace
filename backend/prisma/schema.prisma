generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ==================== USUARIOS ====================

model User {
  id           Int     @id @default(autoincrement())
  email        String  @unique
  passwordHash String
  name         String
  phone        String?
  cedula       String?
  avatar       String?

  roleId Int
  role   Role @relation(fields: [roleId], references: [id])

  status UserStatus @default(ACTIVE)

  resetToken    String?
  resetTokenExp DateTime?

  addresses Address[]
  orders    Order[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Address {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  label      String
  address    String
  city       String
  department String?
  postalCode String?
  country    String  @default("Colombia")
  isDefault  Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("addresses")
}

model Role {
  id          Int     @id @default(autoincrement())
  name        String
  slug        String  @unique
  description String
  permissions Json
  isSystem    Boolean @default(false)
  isActive    Boolean @default(true)

  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("roles")
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

// ==================== PRODUCTOS ====================

model Product {
  id          Int    @id @default(autoincrement())
  sku         String @unique
  slug        String @unique
  name        String
  description String @db.Text

  // Relaciones con categoría y tipo de producto
  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  typeId      Int?
  productType ProductType? @relation(fields: [typeId], references: [id], onDelete: SetNull)

  basePrice  Decimal @db.Decimal(10, 2)
  stock      Int     @default(0)
  featured   Boolean @default(false)
  isActive   Boolean @default(true)
  isTemplate Boolean @default(false) // Si es true, es un modelo/plantilla para personalización

  images Json
  tags   Json

  // Imágenes por tipo de zona (solo para templates)
  // Formato: { "front": "url/base64", "back": "url/base64", ... }
  zoneTypeImages Json?

  // Zonas de diseño (habilitadas y bloqueadas) para personalización (solo para templates)
  // Formato: { "front": [{ type: "allowed|blocked", shape: "rect|circle|polygon", x, y, width, height, ... }], ... }
  designZones Json?

  // @deprecated - usar designZones
  exclusionZones Json?

  // Relaciones many-to-many con colores y tallas
  productColors ProductColor[]
  productSizes  ProductSize[]

  rating       Decimal? @db.Decimal(2, 1)
  reviewsCount Int?

  orderItems OrderItem[]

  // Relación con zonas de template (si isTemplate = true)
  templateZones TemplateZone[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("products")
}

model Size {
  id           Int     @id @default(autoincrement())
  name         String
  abbreviation String  @unique
  sortOrder    Int
  isActive     Boolean @default(true)

  productSizes     ProductSize[]
  productTypeSizes ProductTypeSize[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sizes")
}

model Color {
  id       Int     @id @default(autoincrement())
  name     String
  slug     String  @unique
  hexCode  String
  isActive Boolean @default(true)

  productColors ProductColor[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("colors")
}

// Tabla intermedia para productos y colores
model ProductColor {
  id        Int     @id @default(autoincrement())
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  colorId   Int
  color     Color   @relation(fields: [colorId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([productId, colorId])
  @@map("product_colors")
}

// Tabla intermedia para productos y tallas
model ProductSize {
  id        Int     @id @default(autoincrement())
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  sizeId    Int
  size      Size    @relation(fields: [sizeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([productId, sizeId])
  @@map("product_sizes")
}

// Tabla intermedia para tipos de producto y tallas
model ProductTypeSize {
  id            Int         @id @default(autoincrement())
  productTypeId Int
  productType   ProductType @relation(fields: [productTypeId], references: [id], onDelete: Cascade)
  sizeId        Int
  size          Size        @relation(fields: [sizeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([productTypeId, sizeId])
  @@map("product_type_sizes")
}

model Category {
  id          Int     @id @default(autoincrement())
  name        String
  slug        String  @unique
  description String?
  isActive    Boolean @default(true)

  productTypes ProductType[]
  products     Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("categories")
}

model ProductType {
  id          Int     @id @default(autoincrement())
  name        String
  slug        String  @unique
  description String?
  isActive    Boolean @default(true)

  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  products         Product[]
  productTypeSizes ProductTypeSize[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("product_types")
}

// ==================== PEDIDOS ====================

model Order {
  id          Int    @id @default(autoincrement())
  orderNumber String @unique

  userId Int
  user   User @relation(fields: [userId], references: [id])

  items OrderItem[]

  subtotal     Decimal @db.Decimal(10, 2)
  shippingCost Decimal @db.Decimal(10, 2)
  discount     Decimal @default(0) @db.Decimal(10, 2)
  tax          Decimal @db.Decimal(10, 2)
  total        Decimal @db.Decimal(10, 2)

  status        OrderStatus @default(PENDING)
  paymentMethod String // Método preferido (puede cambiar con cada intento)
  paymentRef    String? // Referencia del último pago exitoso

  shipping       Json
  trackingNumber String?
  trackingUrl    String?
  notes          String? @db.Text

  statusHistory Json

  // Relación con pagos (un pedido puede tener múltiples intentos de pago)
  payments Payment[]

  paidAt      DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("orders")
}

model OrderItem {
  id      Int   @id @default(autoincrement())
  orderId Int
  order   Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId    Int
  product      Product @relation(fields: [productId], references: [id])
  productName  String
  productImage String

  size      String
  color     String
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)

  customization Json?

  createdAt DateTime @default(now())

  @@map("order_items")
}

enum OrderStatus {
  PENDING
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

// ==================== PAGOS ====================

model Payment {
  id          Int    @id @default(autoincrement())
  orderId     Int
  order       Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Información de la transacción
  transactionId String? @unique // ID de la pasarela de pago (Wompi, MercadoPago, etc.)
  paymentMethod String           // "wompi", "mercadopago", "transferencia", "efectivo", etc.

  // Montos
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("COP")

  // Estado del pago
  status PaymentStatus @default(PENDING)

  // Comprobantes
  receiptUrl  String? @db.VarChar(500) // URL del comprobante de pago
  receiptData String? @db.LongText     // Comprobante en base64 (si se sube imagen)

  // Información adicional del pago
  payerName     String? // Nombre del pagador
  payerEmail    String? // Email del pagador
  payerPhone    String? // Teléfono del pagador
  payerDocument String? // Documento del pagador

  // Razón de fallo/cancelación
  failureReason String? @db.Text
  failureCode   String? // Código de error de la pasarela

  // Verificación manual
  verifiedBy Int? // ID del usuario admin que verificó manualmente
  verifiedAt DateTime? // Cuando se verificó el pago
  notes      String? @db.Text // Notas del admin sobre el pago

  // Reembolsos
  refundedAmount Decimal @default(0) @db.Decimal(10, 2)
  refundedAt     DateTime?
  refundReason   String? @db.Text

  // Timestamps importantes
  initiatedAt DateTime @default(now()) // Cuando se inició el intento de pago
  paidAt      DateTime? // Cuando se confirmó el pago
  failedAt    DateTime? // Cuando falló el pago
  cancelledAt DateTime? // Cuando se canceló
  expiredAt   DateTime? // Cuando expiró el intento

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([transactionId])
  @@index([status])
  @@index([paymentMethod])
  @@index([initiatedAt])
  @@map("payments")
}

enum PaymentStatus {
  PENDING       // Pago iniciado, esperando confirmación
  PROCESSING    // En proceso de verificación
  APPROVED      // Pago aprobado y confirmado
  DECLINED      // Pago rechazado por el banco/pasarela
  FAILED        // Pago fallido (error técnico)
  CANCELLED     // Pago cancelado por el usuario
  EXPIRED       // Intento de pago expirado
  REFUNDED      // Pago reembolsado completamente
  PARTIAL_REFUND // Reembolso parcial
}

// ==================== CONFIGURACION ====================

model Setting {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt

  @@map("settings")
}

// ==================== TEMPLATES Y ZONAS ====================

// Tipo de Zona (catálogo: Frente, Espalda, Mangas, etc.)
model ZoneType {
  id          Int     @id @default(autoincrement())
  name        String // "Frente", "Espalda", "Manga"
  slug        String  @unique // "front", "back", "sleeve"
  description String? @db.Text
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)

  zones TemplateZone[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("zone_types")
}

// Zona específica de un template
model TemplateZone {
  id         Int     @id @default(autoincrement())
  templateId Int // FK a Product (donde isTemplate = true)
  template   Product @relation(fields: [templateId], references: [id], onDelete: Cascade)

  zoneTypeId Int // FK a ZoneType
  zoneType   ZoneType @relation(fields: [zoneTypeId], references: [id])

  // Identificador de zona según PrintZone type
  zoneId String // 'front-regular', 'back-large', 'sleeve-small', etc.

  // Información de la zona
  name        String // "Frente Regular (18x25cm)"
  description String? @db.Text

  // Forma de la zona: rect, circle, polygon
  shape String @default("rect") // 'rect' | 'circle' | 'polygon'

  // Dimensiones máximas de la zona (en porcentaje 0-100)
  maxWidth  Int // Ancho en %
  maxHeight Int // Alto en %

  // Posición en el canvas (en porcentaje 0-100)
  positionX Int // Coordenada X en %
  positionY Int // Coordenada Y en %

  // Para círculos (radio en %)
  radius Int? // Solo para shape='circle'

  // Para polígonos (puntos relativos 0-100 dentro del bounding box)
  // Formato JSON: [{"x": 50, "y": 0}, {"x": 100, "y": 100}, {"x": 0, "y": 100}]
  points Json?

  // Control de usuario
  isEditable Boolean @default(true) // Si el usuario puede modificar esta zona
  isRequired Boolean @default(false) // Si es obligatorio que el usuario agregue diseño

  // NUEVO: Si es zona bloqueada (donde NO se puede poner diseño)
  isBlocked Boolean @default(false) // true = zona bloqueada (roja), false = zona de diseño (normal)

  sortOrder Int     @default(0)
  isActive  Boolean @default(true)

  // Una zona puede tener UN insumo predefinido (solo para zonas no bloqueadas)
  zoneInput ZoneInput?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
  @@index([zoneTypeId])
  @@map("template_zones")
}

// Insumo/Diseño predefinido de una zona
model ZoneInput {
  id             Int          @id @default(autoincrement())
  templateZoneId Int          @unique // FK a TemplateZone (relación 1:1)
  templateZone   TemplateZone @relation(fields: [templateZoneId], references: [id], onDelete: Cascade)

  // Relación con insumo del inventario
  inputId Int? // FK a Input (insumo del inventario)
  input   Input? @relation(fields: [inputId], references: [id], onDelete: SetNull)

  // Imagen del insumo
  imageUrl          String // URL pública de la imagen
  imageData         String? @db.LongText // Base64 comprimida (para preview rápido)
  originalImageData String? @db.LongText // Base64 original (para producción)
  fileName          String?
  fileSize          Int? // Tamaño en bytes

  // Propiedades del diseño
  positionX Int   @default(0)
  positionY Int   @default(0)
  width     Int   @default(100)
  height    Int   @default(100)
  rotation  Float @default(0) // En grados
  opacity   Float @default(1) // 0 a 1

  // Control
  isLocked Boolean @default(false) // Si está bloqueado, el usuario NO puede modificar/eliminar

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([inputId])
  @@map("zone_inputs")
}

// ==================== INVENTARIO DE INSUMOS ====================

// Tipo de Insumo (DTF, Vinilo, Sublimación, etc.)
model InputType {
  id          Int     @id @default(autoincrement())
  name        String // "DTF", "Vinilo Textil", "Sublimación"
  slug        String  @unique // "dtf", "vinilo-textil", "sublimacion"
  description String? @db.Text
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)

  inputs Input[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("input_types")
}

// Insumo (material de inventario)
model Input {
  id          Int     @id @default(autoincrement())
  code        String  @unique // Código único del insumo
  name        String // Nombre descriptivo
  description String? @db.Text

  inputTypeId Int // FK a InputType
  inputType   InputType @relation(fields: [inputTypeId], references: [id])

  // Información del insumo
  unitOfMeasure String // "cm²", "unidad", "metro", etc.
  unitCost      Decimal @db.Decimal(10, 2) // Costo por unidad

  // Stock
  currentStock Decimal @default(0) @db.Decimal(10, 2) // Stock actual
  minStock     Decimal @default(0) @db.Decimal(10, 2) // Stock mínimo (alerta)
  maxStock     Decimal @default(0) @db.Decimal(10, 2) // Stock máximo

  // Información adicional
  supplier     String? // Proveedor
  supplierCode String? // Código del proveedor
  notes        String? @db.Text

  isActive Boolean @default(true)

  // Relaciones
  batches    InputBatch[] // Lotes de este insumo
  movements  InputBatchMovement[] // Movimientos de inventario
  zoneInputs ZoneInput[] // Zonas que usan este insumo

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([inputTypeId])
  @@map("inputs")
}

// Lote de Insumo (entrada de inventario)
model InputBatch {
  id      Int   @id @default(autoincrement())
  inputId Int // FK a Input
  input   Input @relation(fields: [inputId], references: [id], onDelete: Cascade)

  batchNumber String // Número de lote
  supplier    String? // Proveedor de este lote
  invoiceRef  String? // Referencia de factura

  // Cantidades
  initialQuantity  Decimal @db.Decimal(10, 2) // Cantidad inicial del lote
  currentQuantity  Decimal @db.Decimal(10, 2) // Cantidad actual disponible
  reservedQuantity Decimal @default(0) @db.Decimal(10, 2) // Cantidad reservada

  // Costos
  unitCost  Decimal @db.Decimal(10, 2) // Costo unitario de este lote
  totalCost Decimal @db.Decimal(10, 2) // Costo total del lote

  // Fechas
  purchaseDate DateTime? // Fecha de compra
  expiryDate   DateTime? // Fecha de vencimiento (si aplica)

  notes String? @db.Text

  isActive Boolean @default(true)

  movements InputBatchMovement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([inputId, batchNumber])
  @@index([inputId])
  @@map("input_batches")
}

// Movimiento de Lote de Insumo
model InputBatchMovement {
  id           Int        @id @default(autoincrement())
  inputId      Int // FK a Input
  input        Input      @relation(fields: [inputId], references: [id], onDelete: Cascade)
  inputBatchId Int // FK a InputBatch
  inputBatch   InputBatch @relation(fields: [inputBatchId], references: [id], onDelete: Cascade)

  movementType MovementType // ENTRADA, SALIDA, AJUSTE, RESERVA, LIBERACION
  quantity     Decimal      @db.Decimal(10, 2) // Cantidad del movimiento (positiva o negativa)

  // Referencias
  referenceType String? // "order", "production", "adjustment", "return"
  referenceId   Int? // ID de la referencia (ej: orderId, productionId)

  reason String? @db.Text // Razón del movimiento
  notes  String? @db.Text

  userId Int? // Usuario que realizó el movimiento

  createdAt DateTime @default(now())

  @@index([inputId])
  @@index([inputBatchId])
  @@index([movementType])
  @@index([createdAt])
  @@map("input_batch_movements")
}

enum MovementType {
  ENTRADA // Entrada de inventario (compra)
  SALIDA // Salida de inventario (uso en producción)
  AJUSTE // Ajuste de inventario (corrección)
  RESERVA // Reserva de inventario (para orden)
  LIBERACION // Liberación de reserva
  DEVOLUCION // Devolución
  MERMA // Pérdida/merma
}

// ==================== CATÁLOGO DE IMÁGENES DE DISEÑO ====================

// Imágenes prediseñadas para el personalizador
model DesignImage {
  id          Int     @id @default(autoincrement())
  name        String // Nombre descriptivo
  description String? @db.Text

  // URLs de las imágenes
  thumbnailUrl String @db.LongText // Base64 o URL de imagen pequeña/comprimida (para preview)
  fullUrl      String @db.VarChar(500) // URL de imagen original/alta calidad (para pedido)

  // Metadatos
  category String? // Categoría: "iconos", "logos", "textos", "decorativos", etc.
  tags     Json? // Array de etiquetas para búsqueda: ["corazón", "amor", "rojo"]

  sortOrder Int     @default(0)
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([isActive])
  @@map("design_images")
}
